<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spacial Indexing: The Adaptive Hash Grid Algorithm | üêò‚≠êüéà</title>
<meta name=keywords content><meta name=description content="I&rsquo;ve been exploring spatial indexing lately, trying to balance performance and
simplicity in scenarios where objects of varying sizes need to be indexed and
queried quickly. This led me to experiment with what I&rsquo;m calling an Adaptive
Hash Grid (AHGrid). It may not be entirely novel, but I think it&rsquo;s an
interesting approach to tackling a few common challenges. I&rsquo;ve combined ideas
from a few other algorithms to make this work."><meta name=author content><link rel=canonical href=https://elephantstarballoon.com/post/ahgrid/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://elephantstarballoon.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://elephantstarballoon.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://elephantstarballoon.com/favicon-32x32.png><link rel=apple-touch-icon href=https://elephantstarballoon.com/apple-touch-icon.png><link rel=mask-icon href=https://elephantstarballoon.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://elephantstarballoon.com/post/ahgrid/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>@media(min-width:800px){.right-img{float:right;padding-left:20px}}</style><meta property="og:url" content="https://elephantstarballoon.com/post/ahgrid/"><meta property="og:site_name" content="üêò‚≠êüéà"><meta property="og:title" content="Spacial Indexing: The Adaptive Hash Grid Algorithm"><meta property="og:description" content="I‚Äôve been exploring spatial indexing lately, trying to balance performance and simplicity in scenarios where objects of varying sizes need to be indexed and queried quickly. This led me to experiment with what I‚Äôm calling an Adaptive Hash Grid (AHGrid). It may not be entirely novel, but I think it‚Äôs an interesting approach to tackling a few common challenges. I‚Äôve combined ideas from a few other algorithms to make this work."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-21T08:00:00-08:00"><meta property="article:modified_time" content="2025-03-21T08:00:00-08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spacial Indexing: The Adaptive Hash Grid Algorithm"><meta name=twitter:description content="I&rsquo;ve been exploring spatial indexing lately, trying to balance performance and
simplicity in scenarios where objects of varying sizes need to be indexed and
queried quickly. This led me to experiment with what I&rsquo;m calling an Adaptive
Hash Grid (AHGrid). It may not be entirely novel, but I think it&rsquo;s an
interesting approach to tackling a few common challenges. I&rsquo;ve combined ideas
from a few other algorithms to make this work."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://elephantstarballoon.com/post/"},{"@type":"ListItem","position":2,"name":"Spacial Indexing: The Adaptive Hash Grid Algorithm","item":"https://elephantstarballoon.com/post/ahgrid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spacial Indexing: The Adaptive Hash Grid Algorithm","name":"Spacial Indexing: The Adaptive Hash Grid Algorithm","description":"I\u0026rsquo;ve been exploring spatial indexing lately, trying to balance performance and simplicity in scenarios where objects of varying sizes need to be indexed and queried quickly. This led me to experiment with what I\u0026rsquo;m calling an Adaptive Hash Grid (AHGrid). It may not be entirely novel, but I think it\u0026rsquo;s an interesting approach to tackling a few common challenges. I\u0026rsquo;ve combined ideas from a few other algorithms to make this work.\n","keywords":[],"articleBody":"I‚Äôve been exploring spatial indexing lately, trying to balance performance and simplicity in scenarios where objects of varying sizes need to be indexed and queried quickly. This led me to experiment with what I‚Äôm calling an Adaptive Hash Grid (AHGrid). It may not be entirely novel, but I think it‚Äôs an interesting approach to tackling a few common challenges. I‚Äôve combined ideas from a few other algorithms to make this work.\nThe Problem with Traditional Grids If you‚Äôve ever used a basic grid to index objects in a 2D space, you‚Äôve probably hit a familiar problem: What happens when an object spans multiple cells?\nImagine a grid where each cell is exactly 10 units wide and 10 units tall. If you insert a an object that is 15x15 into that grid, it will overlap multiple cells, forcing you to register the object with each cell it overlaps. When querying for nearby objects, you have to check all four cells and deduplicate any results if they straddle multiple cells.\nQuadtrees and Hierarchical Spatial Hash Grids have the same problem as a classical fixed size grid ‚Äì they all require storing an object in all the cells that it overlaps. This is because the edges between cells are fixed.\nI also wanted a system that could represent objects of wildly varying size spread out across a basically unbound space (low(int32)..high(int32)).\nAdaptive Hasing Grid AHGrid overcomes these limitations in two ways:\nThere are multiple layers in the grid. Each layer is 2x as big as the previous layer. The boundaries between each layer are always at an offset from the layer beneath it. You can see what that means here:\nEach layer scales up by 2, and the first index is offset from the layer above.\nWhen inserting an object into the grid, it means we can avoid overlaps by first finding the smallest layer that can fully contain that object. A simple example of that can be seen here:\nIn that example, the object is 3 units wide at offset 3. We can immediately bump the width up to the next power of 2, which puts us at a scale of 4. And because the object fits entirely within the cell from 2 to 5, we‚Äôre done.\nIf the object overlaps the edge of its cell, we move to the next layer up until we find a layer that doesn‚Äôt overlap. This allows us to guarantee that each object is only ever inserted into exactly one cell. You can see the same object as below, but this time an offset of 4 puts the right side of the object over the boundary of the cell:\nIn this case, we can bump the scale up to 8 and the object now fits entirely within a single cell at the next layer up.\nIn code To see how this works, lets look at the implementation. Imagine we want to insert 2D object with x, y, width and height parameters:\ntype SpatialObject* = concept obj obj.x is int32 obj.y is int32 obj.width is int32 obj.height is int32 First, we choose the layer that best fits this object. We‚Äôre calling this the scale. Because each layer is a power of 2, we just need to find the next power of two based on the maximum width or height:\nvar scale = max(obj.width, obj.height).int.nextPowerOfTwo.int32 Second, we choose the cell index that the object would fall into. This looks the same for both x and y. In a Hierarchical Spatial Hash Grid, this would just be coord div scale. But because we need to offset the root coordinate for each layer by half the scale, we need to get a bit fancier:\nproc cellIndex(coord, scale: int32): int32 = let half = scale div 2 let adjust = if coord + half \u003e= 0: 0'i32 else: -scale + 1 return (coord + half + adjust) div scale * scale - half Third, we make sure the object we‚Äôre processing fits entirely within the cell we‚Äôve picked. If it doesn‚Äôt, then we need to increase the scale of the cell until the object fits entirely within it. We call the output of this a CellIndex because it‚Äôs the value we later use to index all the objects that are near each other.\ntype CellIndex = tuple[x, y, scale: int32] proc pickCellIndex(grid: AHGrid, x, y, width, height: int32): CellIndex = var scale = max(width, height).int.nextPowerOfTwo.int32 while true: let output = (x: x.cellIndex(scale), y: y.cellIndex(scale), scale: scale) if x + width \u003c output.x + scale and y + height \u003c output.y + scale: return output scale = scale * 2 Put that all together and we have now picked the cell that we know will fit the entire object in it.\nStorage and Inserting As the name of the algorithm would imply, the values being index are stored in a table. All the values with the same CellIndex are stored together, as they, by definition, are near each other. It looks like this:\ntype AHGrid*[T: SpatialObject] = object maxScale: int32 cells: Table[CellIndex, seq[T]] Notice that we also need to store the maxScale. That‚Äôs in there so that queries know how many layers they need to query before stopping.\nWith the type definition above, inserting an object can be done in linear time:\nproc insert*[T](grid: var AHGrid[T], obj: T) = let key = obj.pickCellIndex(grid) grid.maxScale = max(grid.maxScale, key.scale) grid.cells.mgetOrPut(key, newSeq[T]()).add(obj) Querying at a point To now find all the objects that are near a given point, we can implement a query by calculating the CellIndex for each scale within the grid. Visually, if you wanted to query for anything that exists at the 1d coordinate 8, it would look like this:\nIn code, that looks like:\niterator eachScale(grid: AHGrid): int32 = var scale = 0 while scale \u003c= grid.maxScale: yield scale scale *= 2 iterator find*[T](grid: AHGrid[T]; x, y: int32): T = for scale in grid.eachScale: let key = pickCellIndex(x, y, scale) for obj in grid.cells.getOrDefault(keys): yield obj This dynamic scaling adapts smoothly to the size and spread of the data, minimizing unnecessary checks.\nQuerying with a radius We can further expand the querying capability by adding in a radius for our query. This requires doing a search for every CellIndex that is within the radius of the search point:\nIn code, that looks like:\niterator eachCellIndex(x, y, radius, scale: int32): CellIndex = let xRange = cellIndex(x - radius, scale)..cellIndex(x + radius, scale) let yRange = cellIndex(y - radius, scale)..cellIndex(y + radius, scale) for x in countup(xRange.a, xRange.b, scale): for y in countup(yRange.a, yRange.b, scale): yield (x, y, scale) iterator find*[T](grid: AHGrid[T]; x, y, radius: int32): T = for scale in grid.eachScale: for key in eachCellIndex(x, y, radius, scale): for obj in grid.cells.getOrDefault(key): yield obj Optimizing usage To make the most of the AHGrid approach, there are a few optimization strategies to consider:\nInitial Sizing for Hash Tables and Lists\nWhen initializing your hash tables and nested lists, it‚Äôs helpful to estimate the number of cells and objects you expect to store. By pre-allocating space in your hash table and object lists, you can avoid costly reallocations as the data grows. If you expect a large, sparse distribution of data, you may want to use a more aggressive initial capacity for the hash table.\nAdding a Minimum Scale (minScale)\nAnother critical parameter that can be added to this implementation is the notion of a ‚Äúminimum scale‚Äù, or minScale. This value sets the smallest cell size used by the grid, acting as a lower bound for the scale factor. If the minScale is too small, queries will need to search through many cells, increasing the cost of each lookup. If it‚Äôs too large, you lose the granularity and benefits of a spatial index.\nAlternate Approaches and Comparisons While the Adaptive Hash Grid has proven effective for my needs, it‚Äôs helpful to understand how it compares to other spatial hashing techniques. Here are a few common approaches:\nFixed-Size Grids: These are simple to implement but suffer from overlapping issues when objects span multiple cells. They also struggle with varying object sizes or non-uniformly distributed data. Quadtrees: Quadtrees dynamically divide space, making them suitable for varied object sizes. However, they can become unbalanced with irregular data distributions and often require complicated balancing or depth-limited optimizations. Hierarchical Spatial Hash Grids: These are more flexible than fixed grids, leveraging multiple levels of granularity. However, objects still overlap cells across levels, necessitating deduplication during querying. The Adaptive Hash Grid strikes a balance between these approaches. By adjusting cell sizes dynamically while maintaining a flat hash table, AHGrid reduces overlaps, minimizes query time, and simplifies implementation.\nStrengths of this approach Simplicity: Uses a flat hash table ‚Äî no deep tree traversals, no rebalancing. This algorithm is really easy to implement Adaptability: Supports objects of any size within a single cell. Efficient Queries: No deduplication needed due to unique cell assignment. Infinite Space: Because we‚Äôre using a hash table to store the data, we can store two objects that are at opposite ends of a grid as efficiently as storing two that are close together Conclusion I‚Äôve been using this for Game development, where I need to quickly and dynamically index a large number of game entities ‚Äì it has worked well so far!\nIf you‚Äôre interested in seeing all this code together, I‚Äôve got a working implementation over on Github: https://github.com/Nycto/AHGrid\n","wordCount":"1561","inLanguage":"en","datePublished":"2025-03-21T08:00:00-08:00","dateModified":"2025-03-21T08:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://elephantstarballoon.com/post/ahgrid/"},"publisher":{"@type":"Organization","name":"üêò‚≠êüéà","logo":{"@type":"ImageObject","url":"https://elephantstarballoon.com/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://elephantstarballoon.com/ accesskey=h title="üêò‚≠êüéà (Alt + H)">üêò‚≠êüéà</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://github.com/Nycto title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://mstdn.games/@Nycto title=Mastadon><span>Mastadon</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://bsky.app/profile/jarmsicle.bsky.social title=BlueSky><span>BlueSky</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://elephantstarballoon.itch.io/ title=Itch><span>Itch</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Spacial Indexing: The Adaptive Hash Grid Algorithm</h1><div class=post-meta><span title='2025-03-21 08:00:00 -0800 -0800'>March 21, 2025</span></div></header><div class=post-content><p>I&rsquo;ve been exploring spatial indexing lately, trying to balance performance and
simplicity in scenarios where objects of varying sizes need to be indexed and
queried quickly. This led me to experiment with what I&rsquo;m calling an <strong>Adaptive
Hash Grid</strong> (AHGrid). It may not be entirely novel, but I think it&rsquo;s an
interesting approach to tackling a few common challenges. I&rsquo;ve combined ideas
from a few other algorithms to make this work.</p><h2 id=the-problem-with-traditional-grids>The Problem with Traditional Grids<a hidden class=anchor aria-hidden=true href=#the-problem-with-traditional-grids>#</a></h2><p>If you&rsquo;ve ever used a basic grid to index objects in a 2D space, you&rsquo;ve probably
hit a familiar problem: What happens when an object spans multiple cells?</p><p>Imagine a grid where each cell is exactly <code>10 units</code> wide and <code>10 units</code> tall.
If you insert a an object that is 15x15 into that grid, it will overlap multiple
cells, forcing you to register the object with each cell it overlaps. When
querying for nearby objects, you have to check all four cells and deduplicate any
results if they straddle multiple cells.</p><p>Quadtrees and Hierarchical Spatial Hash Grids have the same problem as a classical
fixed size grid &ndash; they all require storing an object in all the cells that it overlaps.
This is because the edges between cells are fixed.</p><p>I also wanted a system that could represent objects of wildly varying size spread
out across a basically unbound space (<code>low(int32)..high(int32)</code>).</p><h2 id=adaptive-hasing-grid>Adaptive Hasing Grid<a hidden class=anchor aria-hidden=true href=#adaptive-hasing-grid>#</a></h2><p>AHGrid overcomes these limitations in two ways:</p><ol><li>There are multiple layers in the grid. Each layer is 2x as big as the previous layer.</li><li>The boundaries between each layer are always at an offset from the layer beneath it.</li></ol><p>You can see what that means here:</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/scales.svg></p><p>Each layer scales up by 2, and the first index is offset from the layer above.</p><p>When inserting an object into the grid, it means we can avoid overlaps by first finding the
smallest layer that can fully contain that object. A simple example of that can be
seen here:</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/insert-simple.svg></p><p>In that example, the object is <code>3 units</code> wide at offset <code>3</code>. We can immediately bump the
width up to the next power of 2, which puts us at a scale of <code>4</code>. And because the object
fits entirely within the cell from <code>2</code> to <code>5</code>, we&rsquo;re done.</p><p>If the object overlaps the edge of its cell, we move to the next layer up until we
find a layer that doesn&rsquo;t overlap. This allows us to guarantee that each object is
only ever inserted into exactly one cell. You can see the same object as below, but this
time an offset of <code>4</code> puts the right side of the object over the boundary of the cell:</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/insert-bumped.svg></p><p>In this case, we can bump the scale up to <code>8</code> and the object now fits entirely within
a single cell at the next layer up.</p><h3 id=in-code>In code<a hidden class=anchor aria-hidden=true href=#in-code>#</a></h3><p>To see how this works, lets look at the implementation. Imagine we want to insert 2D object
with <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code> parameters:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span>
</span></span><span style=display:flex><span>  SpatialObject<span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>concept</span> obj
</span></span><span style=display:flex><span>    obj.x <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.y <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.width <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.height <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span></code></pre></div><p><strong>First</strong>, we choose the layer that best fits this object. We&rsquo;re calling this
the <code>scale</code>. Because each layer is a power of 2, we just need to find the next
power of two based on the maximum width or height:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> max(obj.width, obj.height).<span style=color:#66d9ef>int</span>.nextPowerOfTwo.<span style=color:#66d9ef>int32</span>
</span></span></code></pre></div><p><strong>Second</strong>, we choose the cell index that the object would fall into. This looks
the same for both <code>x</code> and <code>y</code>. In a Hierarchical Spatial Hash Grid, this
would just be <code>coord div scale</code>. But because we need to offset the root
coordinate for each layer by half the scale, we need to get a bit fancier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>cellIndex</span>(coord, scale: <span style=color:#66d9ef>int32</span>): <span style=color:#66d9ef>int32</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> half <span style=color:#f92672>=</span> scale <span style=color:#f92672>div</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> adjust <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> coord <span style=color:#f92672>+</span> half <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>: <span style=color:#ae81ff>0</span><span style=color:#ae81ff>&#39;i32</span> <span style=color:#66d9ef>else</span>: <span style=color:#f92672>-</span>scale <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (coord <span style=color:#f92672>+</span> half <span style=color:#f92672>+</span> adjust) <span style=color:#f92672>div</span> scale <span style=color:#f92672>*</span> scale <span style=color:#f92672>-</span> half
</span></span></code></pre></div><p><strong>Third</strong>, we make sure the object we&rsquo;re processing fits entirely within the
cell we&rsquo;ve picked. If it doesn&rsquo;t, then we need to increase the <code>scale</code> of the
cell until the object fits entirely within it. We call the output of this a
<code>CellIndex</code> because it&rsquo;s the value we later use to index all the objects that
are near each other.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span> CellIndex <span style=color:#f92672>=</span> <span style=color:#66d9ef>tuple</span><span style=color:#f92672>[</span>x, y, scale: <span style=color:#66d9ef>int32</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>pickCellIndex</span>(grid: AHGrid, x, y, width, height: <span style=color:#66d9ef>int32</span>): CellIndex <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> max(width, height).<span style=color:#66d9ef>int</span>.nextPowerOfTwo.<span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>true</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> (x: x.cellIndex(scale), y: y.cellIndex(scale), scale: scale)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>+</span> width <span style=color:#f92672>&lt;</span> output.x <span style=color:#f92672>+</span> scale <span style=color:#f92672>and</span> y <span style=color:#f92672>+</span> height <span style=color:#f92672>&lt;</span> output.y <span style=color:#f92672>+</span> scale:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>    scale <span style=color:#f92672>=</span> scale <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Put that all together and we have now picked the cell that we know will fit the entire
object in it.</p><h2 id=storage-and-inserting>Storage and Inserting<a hidden class=anchor aria-hidden=true href=#storage-and-inserting>#</a></h2><p>As the name of the algorithm would imply, the values being index are stored in a table.
All the values with the same <code>CellIndex</code> are stored together, as they, by definition,
are near each other. It looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span>
</span></span><span style=display:flex><span>  AHGrid<span style=color:#f92672>*[</span>T: SpatialObject<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>object</span>
</span></span><span style=display:flex><span>    maxScale: <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    cells: Table<span style=color:#f92672>[</span>CellIndex, <span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span>T<span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Notice that we also need to store the <code>maxScale</code>. That&rsquo;s in there so that queries know
how many layers they need to query before stopping.</p><p>With the type definition above, inserting an object can be done in linear time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>insert</span><span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: <span style=color:#66d9ef>var</span> AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>, obj: T) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> obj.pickCellIndex(grid)
</span></span><span style=display:flex><span>  grid.maxScale <span style=color:#f92672>=</span> max(grid.maxScale, key.scale)
</span></span><span style=display:flex><span>  grid.cells.mgetOrPut(key, newSeq<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>()).add(obj)
</span></span></code></pre></div><h2 id=querying-at-a-point>Querying at a point<a hidden class=anchor aria-hidden=true href=#querying-at-a-point>#</a></h2><p>To now find all the objects that are near a given point, we can implement a query by
calculating the <code>CellIndex</code> for each <code>scale</code> within the grid. Visually, if you wanted
to query for anything that exists at the 1d coordinate <code>8</code>, it would look like this:</p><p><img alt="query at point" loading=lazy src=/ahgrid/query-point.svg></p><p>In code, that looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>iterator</span> eachScale(grid: AHGrid): <span style=color:#66d9ef>int32</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> scale <span style=color:#f92672>&lt;=</span> grid.maxScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> scale
</span></span><span style=display:flex><span>    scale <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>iterator</span> find<span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>; x, y: <span style=color:#66d9ef>int32</span>): T <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> scale <span style=color:#f92672>in</span> grid.eachScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> pickCellIndex(x, y, scale)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> obj <span style=color:#f92672>in</span> grid.cells.getOrDefault(keys):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span> obj
</span></span></code></pre></div><p>This dynamic scaling adapts smoothly to the size and spread of the data, minimizing unnecessary checks.</p><h2 id=querying-with-a-radius>Querying with a radius<a hidden class=anchor aria-hidden=true href=#querying-with-a-radius>#</a></h2><p>We can further expand the querying capability by adding in a radius for our query.
This requires doing a search for every <code>CellIndex</code> that is within the radius of
the search point:</p><p><img alt="query at point" loading=lazy src=/ahgrid/query-range.svg></p><p>In code, that looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>iterator</span> eachCellIndex(x, y, radius, scale: <span style=color:#66d9ef>int32</span>): CellIndex <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> xRange <span style=color:#f92672>=</span> cellIndex(x <span style=color:#f92672>-</span> radius, scale)..cellIndex(x <span style=color:#f92672>+</span> radius, scale)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> yRange <span style=color:#f92672>=</span> cellIndex(y <span style=color:#f92672>-</span> radius, scale)..cellIndex(y <span style=color:#f92672>+</span> radius, scale)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> countup(xRange.a, xRange.b, scale):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> countup(yRange.a, yRange.b, scale):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span> (x, y, scale)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>iterator</span> find<span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>; x, y, radius: <span style=color:#66d9ef>int32</span>): T <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> scale <span style=color:#f92672>in</span> grid.eachScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> eachCellIndex(x, y, radius, scale):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> obj <span style=color:#f92672>in</span> grid.cells.getOrDefault(key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> obj
</span></span></code></pre></div><h2 id=optimizing-usage>Optimizing usage<a hidden class=anchor aria-hidden=true href=#optimizing-usage>#</a></h2><p>To make the most of the AHGrid approach, there are a few optimization strategies to consider:</p><ul><li><p>Initial Sizing for Hash Tables and Lists</p><p>When initializing your hash tables and nested lists, it‚Äôs helpful to estimate
the number of cells and objects you expect to store. By pre-allocating space
in your hash table and object lists, you can avoid costly reallocations as the
data grows. If you expect a large, sparse distribution of data, you may want
to use a more aggressive initial capacity for the hash table.</p></li><li><p>Adding a Minimum Scale (<code>minScale</code>)</p><p>Another critical parameter that can be added to this implementation is the
notion of a &ldquo;minimum scale&rdquo;, or <code>minScale</code>. This value sets the smallest cell
size used by the grid, acting as a lower bound for the <code>scale</code> factor. If the
<code>minScale</code> is too small, queries will need to search through many cells,
increasing the cost of each lookup. If it‚Äôs too large, you lose the
granularity and benefits of a spatial index.</p></li></ul><h2 id=alternate-approaches-and-comparisons>Alternate Approaches and Comparisons<a hidden class=anchor aria-hidden=true href=#alternate-approaches-and-comparisons>#</a></h2><p>While the Adaptive Hash Grid has proven effective for my needs, it&rsquo;s helpful to understand how it compares to other spatial hashing techniques. Here are a few common approaches:</p><ul><li>Fixed-Size Grids: These are simple to implement but suffer from overlapping issues when objects span multiple cells. They also struggle with varying object sizes or non-uniformly distributed data.</li><li>Quadtrees: Quadtrees dynamically divide space, making them suitable for varied object sizes. However, they can become unbalanced with irregular data distributions and often require complicated balancing or depth-limited optimizations.</li><li>Hierarchical Spatial Hash Grids: These are more flexible than fixed grids, leveraging multiple levels of granularity. However, objects still overlap cells across levels, necessitating deduplication during querying.</li></ul><p>The Adaptive Hash Grid strikes a balance between these approaches. By adjusting cell sizes dynamically while maintaining a flat hash table, AHGrid reduces overlaps, minimizes query time, and simplifies implementation.</p><h2 id=strengths-of-this-approach>Strengths of this approach<a hidden class=anchor aria-hidden=true href=#strengths-of-this-approach>#</a></h2><ul><li><strong>Simplicity:</strong> Uses a flat hash table ‚Äî no deep tree traversals, no rebalancing. This
algorithm is <em>really</em> easy to implement</li><li><strong>Adaptability:</strong> Supports objects of any size within a single cell.</li><li><strong>Efficient Queries:</strong> No deduplication needed due to unique cell assignment.</li><li><strong>Infinite Space:</strong> Because we&rsquo;re using a hash table to store the data, we can store
two objects that are at opposite ends of a grid as efficiently as storing two that
are close together</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I&rsquo;ve been using this for Game development, where I need to quickly and dynamically
index a large number of game entities &ndash; it has worked well so far!</p><p>If you&rsquo;re interested in seeing all this code together, I&rsquo;ve got a working implementation
over on Github: <a href=https://github.com/Nycto/AHGrid>https://github.com/Nycto/AHGrid</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://elephantstarballoon.com/>üêò‚≠êüéà</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>