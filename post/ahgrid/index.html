<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spacial Indexing: The Adaptive Hash Grid Algorithm | üêò‚≠êüéà</title>
<meta name=keywords content><meta name=description content="I&rsquo;ve been exploring spatial indexing lately, trying to find a balance
performance and simplicity. While looking at the Hierarchical Spacial Grid Hash
algorithm, I had a thought about how to combine its layering system with a flat
spatial hash. I&rsquo;ve been searching for prior art to determine if this is a &ldquo;new&rdquo;
idea, but haven&rsquo;t found any yet. I&rsquo;m sharing this approach to collect feedback.
For the purpose of this article, I&rsquo;m calling this the Adaptive Hash Grid
algorithm (AHGrid). As I said, it&rsquo;s a twist on a spatial hash that
incorporates the size of the object into the hash key generation. The benefit is
that objects in an AHGrid will only ever be stored in a single cell within the
grid, which simplifies the process of queries and updates. It&rsquo;s also capable of
easily storing objects of varying size spread out across a basically unbound
space (low(int32)..high(int32))."><meta name=author content><link rel=canonical href=https://elephantstarballoon.com/post/ahgrid/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://elephantstarballoon.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://elephantstarballoon.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://elephantstarballoon.com/favicon-32x32.png><link rel=apple-touch-icon href=https://elephantstarballoon.com/apple-touch-icon.png><link rel=mask-icon href=https://elephantstarballoon.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://elephantstarballoon.com/post/ahgrid/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>@media(min-width:800px){.right-img{float:right;padding-left:20px}}</style><meta property="og:url" content="https://elephantstarballoon.com/post/ahgrid/"><meta property="og:site_name" content="üêò‚≠êüéà"><meta property="og:title" content="Spacial Indexing: The Adaptive Hash Grid Algorithm"><meta property="og:description" content="I‚Äôve been exploring spatial indexing lately, trying to find a balance performance and simplicity. While looking at the Hierarchical Spacial Grid Hash algorithm, I had a thought about how to combine its layering system with a flat spatial hash. I‚Äôve been searching for prior art to determine if this is a ‚Äúnew‚Äù idea, but haven‚Äôt found any yet. I‚Äôm sharing this approach to collect feedback.
For the purpose of this article, I‚Äôm calling this the Adaptive Hash Grid algorithm (AHGrid). As I said, it‚Äôs a twist on a spatial hash that incorporates the size of the object into the hash key generation. The benefit is that objects in an AHGrid will only ever be stored in a single cell within the grid, which simplifies the process of queries and updates. It‚Äôs also capable of easily storing objects of varying size spread out across a basically unbound space (low(int32)..high(int32))."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-21T08:00:00-08:00"><meta property="article:modified_time" content="2025-03-21T08:00:00-08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spacial Indexing: The Adaptive Hash Grid Algorithm"><meta name=twitter:description content="I&rsquo;ve been exploring spatial indexing lately, trying to find a balance
performance and simplicity. While looking at the Hierarchical Spacial Grid Hash
algorithm, I had a thought about how to combine its layering system with a flat
spatial hash. I&rsquo;ve been searching for prior art to determine if this is a &ldquo;new&rdquo;
idea, but haven&rsquo;t found any yet. I&rsquo;m sharing this approach to collect feedback.
For the purpose of this article, I&rsquo;m calling this the Adaptive Hash Grid
algorithm (AHGrid). As I said, it&rsquo;s a twist on a spatial hash that
incorporates the size of the object into the hash key generation. The benefit is
that objects in an AHGrid will only ever be stored in a single cell within the
grid, which simplifies the process of queries and updates. It&rsquo;s also capable of
easily storing objects of varying size spread out across a basically unbound
space (low(int32)..high(int32))."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://elephantstarballoon.com/post/"},{"@type":"ListItem","position":2,"name":"Spacial Indexing: The Adaptive Hash Grid Algorithm","item":"https://elephantstarballoon.com/post/ahgrid/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spacial Indexing: The Adaptive Hash Grid Algorithm","name":"Spacial Indexing: The Adaptive Hash Grid Algorithm","description":"I\u0026rsquo;ve been exploring spatial indexing lately, trying to find a balance performance and simplicity. While looking at the Hierarchical Spacial Grid Hash algorithm, I had a thought about how to combine its layering system with a flat spatial hash. I\u0026rsquo;ve been searching for prior art to determine if this is a \u0026ldquo;new\u0026rdquo; idea, but haven\u0026rsquo;t found any yet. I\u0026rsquo;m sharing this approach to collect feedback.\nFor the purpose of this article, I\u0026rsquo;m calling this the Adaptive Hash Grid algorithm (AHGrid). As I said, it\u0026rsquo;s a twist on a spatial hash that incorporates the size of the object into the hash key generation. The benefit is that objects in an AHGrid will only ever be stored in a single cell within the grid, which simplifies the process of queries and updates. It\u0026rsquo;s also capable of easily storing objects of varying size spread out across a basically unbound space (low(int32)..high(int32)).\n","keywords":[],"articleBody":"I‚Äôve been exploring spatial indexing lately, trying to find a balance performance and simplicity. While looking at the Hierarchical Spacial Grid Hash algorithm, I had a thought about how to combine its layering system with a flat spatial hash. I‚Äôve been searching for prior art to determine if this is a ‚Äúnew‚Äù idea, but haven‚Äôt found any yet. I‚Äôm sharing this approach to collect feedback.\nFor the purpose of this article, I‚Äôm calling this the Adaptive Hash Grid algorithm (AHGrid). As I said, it‚Äôs a twist on a spatial hash that incorporates the size of the object into the hash key generation. The benefit is that objects in an AHGrid will only ever be stored in a single cell within the grid, which simplifies the process of queries and updates. It‚Äôs also capable of easily storing objects of varying size spread out across a basically unbound space (low(int32)..high(int32)).\nThe Problem with Traditional Grids If you‚Äôve ever used a basic grid to index objects in a 2D space, you‚Äôve probably hit a familiar problem: What happens when an object spans multiple cells?\nImagine a grid where each cell is exactly 10 units wide and 10 units tall. If you insert an object that is 15x15 into that grid, it will overlap multiple cells, forcing you to register the object with each cell it overlaps.\nWhen querying for nearby objects, you have to check all four cells and deduplicate any results if they straddle multiple cells. Querying for neighbors can quickly balloon to searching through dozens of cells.\nQuadtrees and Hierarchical Spatial Hash Grids have the same problem as a classical fixed size grid ‚Äì they require storing an object in all the cells that it overlaps.\nAdaptive Hashing Grid AHGrid is very similar to a spatial hash grid in that it stores objects in a multimap using a calculated index to colocate objects that are nearby:\nTable[CellIndex, seq[T]] In a regular spacial hash, CellIndex above would essentially be:\ntype CellIndex = tuple[xBucket, yBucket: int32] ## CellIndex for a regular spatial hash grid proc cellIndexForSpatialHash(x, y: int32): CellIndex = return (xBucket: x div cellSize, yBucket: y div cellSize) AHGrid also uses an xBucket and yBucket, but then adds a concept of scale:\ntype CellIndex = tuple[xBucket, yBucket, scale: int32] ## CellIndex for an AHGrid The scale property holds the size of the object, rounded up to the next power of two. The calculation for the scale is exactly what you would expect:\nproc calculateScale(width, height: int32): int32 = max(width, height).int.nextPowerOfTwo.int32 This create an important property of an AHGrid: there are multiple layers transparently overlaid within the same Table. Each new value for scale constitutes a new layer. For each layer, the scale is twice as big as the previous layer, so it can contain objects that are twice as big. This is very similar to how a Hierarchical Spatial Hash Grid works in concept, but flattened into a single storage container.\nThe next twist is that every layer in an AHGrid offsets its root coordinate by half its size. This leads to a very important property: adjacent layers don‚Äôt usually share the same edges between cells. Put another way, the boundaries between each cell in a layer are always at an offset from the layer beneath it. In one dimensional space, that looks like this:\nThis offset is what allows us to put an object into exactly one cell ‚Äì if an object overlaps an edge in one layer, we just need to bump up to the next layer.\nBeing in one cell allows queries and updates to be more efficient, as we don‚Äôt have to worry about deduplicating the results. We know that we can blindly emit all the values within a cell without tracking what has already been returned.\nLet‚Äôs walk through the insertion process to see how this works.\nInsert operation To insert an object into the grid, we start by finding the smallest layer that can fully contain that object:\nAbove, the object is 3 units wide at an offset of 3. We can immediately choose an initial scale by bumping the size up to the next power of 2, which puts us at a scale of 4. And because the object fits entirely within the cell from 2 to 5, we‚Äôre done.\nHowever, if we do the above operation and the object overlaps the edge of its destination cell, we need to keep working. To ensure it fits in exactly one cell, we move up to the next layer until we find a cell where the object doesn‚Äôt overlap the boundaries.\nIn the image above, you can see the same object as before, but this time it has an offset of 4. That puts the right edge over the right side boundary of the cell. In this case, we can bump the scale up to 8 and the object now fits entirely within a single cell.\nIn code Lets look at the code for this. Imagine we want to insert a 2D object with x, y, width and height parameters:\ntype SpatialObject* = concept obj obj.x is int32 obj.y is int32 obj.width is int32 obj.height is int32 First, we choose the smallest layer that best fits this object. Because the cell size for each layer is a power of 2, we just need to find the next power of two based on the maximum width or height. That‚Äôs the function we already showed above:\nvar scale = calculateScale(obj.width, obj.height) Second, we examine the x and y coordinates and independently choose a cell index for each. This is basic bucketing ‚Äì and it the same for both x and y, so we can create a general function that works for both.\nIn a Hierarchical Spatial Hash Grid, this would just be coord div scale. But because we need to offset the root coordinate for each layer by half the scale, we need to get a bit fancier:\nproc chooseBucket(coord, scale: int32): int32 = let half = scale div 2 # We need to specifically adjust the index to handle negative coordinates. This # looks funky because we also have to deal with the shifting root coordinates let adjust = if coord + half \u003e= 0: 0'i32 else: -scale + 1 return (coord + half + adjust) div scale * scale - half Third, we make sure the object we‚Äôre processing fits entirely within the cell we‚Äôve picked. If it doesn‚Äôt, then we need to increase the scale of the cell until the object can be fully contained by a single cell.\nproc pickCellIndex(grid: AHGrid, x, y, width, height: int32): CellIndex = var scale = calculateScale(width, height) while true: let output = (xBucket: x.chooseBucket(scale), yBucket: y.chooseBucket(scale), scale: scale) # Ensure the object fits entirely within the cell if x + width \u003c output.xBucket + scale and y + height \u003c output.yBucket + scale: return output # If it doesn't, try fitting the object into the next layer up scale = scale * 2 Put that all together and we have now picked a single cell that we know will fit the entire object.\nStorage and Inserting As already mentioned, the object being indexed are stored in a table of lists. All the values with the same CellIndex are stored together, as they ‚Äì by definition ‚Äì are near each other. It looks like this:\ntype AHGrid*[T: SpatialObject] = object maxScale: int32 cells: Table[CellIndex, seq[T]] Notice that we also need to store the maxScale. That‚Äôs in there so that queries know how many layers they need to query before stopping. Any time we insert an object, we need to update that maxScale\nWith the type definition above, inserting an object can be done in linear time:\nproc insert*[T](grid: var AHGrid[T], obj: T) = let key = obj.pickCellIndex(grid) grid.maxScale = max(grid.maxScale, key.scale) grid.cells.mgetOrPut(key, newSeq[T]()).add(obj) Querying at a point To find all the objects that are near a given point, we can implement a query by calculating the CellIndex for each scale within the grid at the point of interest. Visually, if you wanted to query for anything that exists at the 1d coordinate 8, it would look like this:\nIn the chart above, we would visit every cell at every layer that intersects with the dashed line. In code, that looks like:\niterator eachScale(grid: AHGrid): int32 = var scale = 0 while scale \u003c= grid.maxScale: yield scale scale *= 2 iterator find*[T](grid: AHGrid[T]; x, y: int32): T = for scale in grid.eachScale: let key = pickCellIndex(x, y, scale) for obj in grid.cells.getOrDefault(keys): yield obj This dynamic scaling adapts smoothly to the size and spread of the data, minimizing unnecessary checks.\nQuerying with a radius Within game development, it‚Äôs common to need to know everything that is within a specific radius of a given point. For example, finding all the enemies that might be impacted by an explosion.\nTo handle this use case, we can add a radius to our query. This requires doing a search for every CellIndex that is within the radius of the search point:\nAgain, we would need to visit every cell that intersects with or is between the two dashed lines above. In code, that looks like:\niterator eachCellIndex(x, y, radius, scale: int32): CellIndex = ## Yields each cell key within a given radius of a point at the given scale let (xLow, xHigh) = (chooseBucket(x - radius, scale), chooseBucket(x + radius, scale)) let (yLow, yHigh)= (chooseBucket(y - radius, scale), chooseBucket(y + radius, scale)) for x in countup(xLow, xHigh, scale): for y in countup(yLow, yHigh, scale): yield (x, y, scale) iterator find*[T](grid: AHGrid[T]; x, y, radius: int32): T = for scale in grid.eachScale: for key in eachCellIndex(x, y, radius, scale): for obj in grid.cells.getOrDefault(key): yield obj Further Optimizations Beyond what is described here, there are a few optimization strategies that need further exploration:\nInitial Sizing for Hash Tables and Lists\nWhen initializing your hash tables and nested lists, it‚Äôs helpful to estimate the number of cells and objects you expect to store. By pre-allocating space in the hash table and object lists, you can avoid costly reallocations as the data grows.\nSkip the hash table entirely\nTechnically, we don‚Äôt even need a Table. We could use an array of arrays and do the index management ourselves. This would let us guarantee that we never have to deal with table resizing.\nAdding a Minimum Scale (minScale)\nAnother critical parameter that can be added to this implementation is the notion of a ‚Äúminimum scale‚Äù, or minScale. This value sets the smallest cell size used by the grid, acting as a lower bound for the scale factor. If the minScale is too small, queries will need to search through many cells, increasing the cost of each lookup. If it‚Äôs too large, you lose the granularity and benefits of a spatial index.\nUse a HashSet instead of a seq\nIn the example code, I‚Äôm using a Table that contains a seq. One possible optimization would be using a HashSet instead. Though I didn‚Äôt discuss the remove or update operations in this article, using a set would potentially make those operations faster.\nStrengths Simplicity: Uses a flat hash table ‚Äî no deep tree traversals, no rebalancing. This algorithm is really easy to implement Adaptability: Supports objects of any size at any position Efficient Queries: No deduplication needed due to unique cell assignments Weaknesses Cache Locality: Because we‚Äôre using a hash table, memory locality could suffer. This is especially noticeable if the grid is large and queries need to traverse multiple levels of scaling. Compared to a linear or tree-based structure, the cache efficiency might be lower.\nLarge Query Radii: A large query radius is going to cause a lot of cells to be visited, reducing efficiency. This could be a bigger issue if large queries are frequent\nInteger only: This implementation relies on a lot of integer based math and doesn‚Äôt really work for floats. Any usage would first need to convert a float to an int. This is trivial with a fixed point system, though.\nScaling Factor Sensitivity: Choosing the right minScale is crucial. If the scaling is off, it can lead to either too many grid levels (increasing overhead) or too few (leading to dense cells that degrade query performance).\nConclusion There are certainly some improvements and extensions that can be made to this implementation. For example, being able to remove objects or update them in place. Supporting 3D objects, too. Those should be fairly straight forward.\nI‚Äôve been using this for Game development, where I need to quickly and dynamically index a large number of game entities ‚Äì it has worked well so far!\nIf you‚Äôre interested in seeing all this code together, I‚Äôve got a working implementation over on Github: https://github.com/Nycto/AHGrid\n","wordCount":"2123","inLanguage":"en","datePublished":"2025-03-21T08:00:00-08:00","dateModified":"2025-03-21T08:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://elephantstarballoon.com/post/ahgrid/"},"publisher":{"@type":"Organization","name":"üêò‚≠êüéà","logo":{"@type":"ImageObject","url":"https://elephantstarballoon.com/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://elephantstarballoon.com/ accesskey=h title="üêò‚≠êüéà (Alt + H)">üêò‚≠êüéà</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://github.com/Nycto title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://mstdn.games/@Nycto title=Mastadon><span>Mastadon</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://bsky.app/profile/jarmsicle.bsky.social title=BlueSky><span>BlueSky</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://elephantstarballoon.itch.io/ title=Itch><span>Itch</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Spacial Indexing: The Adaptive Hash Grid Algorithm</h1><div class=post-meta><span title='2025-03-21 08:00:00 -0800 -0800'>March 21, 2025</span></div></header><div class=post-content><p>I&rsquo;ve been exploring spatial indexing lately, trying to find a balance
performance and simplicity. While looking at the Hierarchical Spacial Grid Hash
algorithm, I had a thought about how to combine its layering system with a flat
spatial hash. I&rsquo;ve been searching for prior art to determine if this is a &ldquo;new&rdquo;
idea, but haven&rsquo;t found any yet. I&rsquo;m sharing this approach to collect feedback.</p><p>For the purpose of this article, I&rsquo;m calling this the <strong>Adaptive Hash Grid</strong>
algorithm (<code>AHGrid</code>). As I said, it&rsquo;s a twist on a spatial hash that
incorporates the size of the object into the hash key generation. The benefit is
that objects in an <code>AHGrid</code> will only ever be stored in a single cell within the
grid, which simplifies the process of queries and updates. It&rsquo;s also capable of
easily storing objects of varying size spread out across a basically unbound
space (<code>low(int32)..high(int32)</code>).</p><h2 id=the-problem-with-traditional-grids>The Problem with Traditional Grids<a hidden class=anchor aria-hidden=true href=#the-problem-with-traditional-grids>#</a></h2><p>If you&rsquo;ve ever used a basic grid to index objects in a 2D space, you&rsquo;ve probably
hit a familiar problem: What happens when an object spans multiple cells?</p><p>Imagine a grid where each cell is exactly <code>10 units</code> wide and <code>10 units</code> tall.
If you insert an object that is 15x15 into that grid, it will overlap multiple
cells, forcing you to register the object with each cell it overlaps.</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/grid-overlap.svg></p><p>When querying for nearby objects, you have to check all four cells and deduplicate any
results if they straddle multiple cells. Querying for neighbors can quickly
balloon to searching through dozens of cells.</p><p>Quadtrees and Hierarchical Spatial Hash Grids have the same problem as a classical
fixed size grid &ndash; they require storing an object in all the cells that it overlaps.</p><h2 id=adaptive-hashing-grid>Adaptive Hashing Grid<a hidden class=anchor aria-hidden=true href=#adaptive-hashing-grid>#</a></h2><p>AHGrid is very similar to a spatial hash grid in that it stores objects in a multimap
using a calculated index to colocate objects that are nearby:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span>Table<span style=color:#f92672>[</span>CellIndex, <span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span>T<span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>In a regular spacial hash, <code>CellIndex</code> above would essentially be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span> CellIndex <span style=color:#f92672>=</span> <span style=color:#66d9ef>tuple</span><span style=color:#f92672>[</span>xBucket, yBucket: <span style=color:#66d9ef>int32</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>## CellIndex for a regular spatial hash grid</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>cellIndexForSpatialHash</span>(x, y: <span style=color:#66d9ef>int32</span>): CellIndex <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (xBucket: x <span style=color:#f92672>div</span> cellSize, yBucket: y <span style=color:#f92672>div</span> cellSize)
</span></span></code></pre></div><p><code>AHGrid</code> also uses an <code>xBucket</code> and <code>yBucket</code>, but then adds a concept of <code>scale</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span> CellIndex <span style=color:#f92672>=</span> <span style=color:#66d9ef>tuple</span><span style=color:#f92672>[</span>xBucket, yBucket, scale: <span style=color:#66d9ef>int32</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>## CellIndex for an AHGrid</span>
</span></span></code></pre></div><p>The <code>scale</code> property holds the size of the object, rounded up to the next power of two.
The calculation for the scale is exactly what you would expect:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>calculateScale</span>(width, height: <span style=color:#66d9ef>int32</span>): <span style=color:#66d9ef>int32</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  max(width, height).<span style=color:#66d9ef>int</span>.nextPowerOfTwo.<span style=color:#66d9ef>int32</span>
</span></span></code></pre></div><p>This create an important property of an <code>AHGrid</code>: there are multiple layers
transparently overlaid within the same <code>Table</code>. Each new value for <code>scale</code>
constitutes a new layer. For each layer, the scale is twice as big as the
previous layer, so it can contain objects that are twice as big. This is very
similar to how a Hierarchical Spatial Hash Grid works in concept, but flattened
into a single storage container.</p><p>The next twist is that every layer in an <code>AHGrid</code> offsets its root coordinate by
half its size. This leads to a very important property: adjacent layers don&rsquo;t
usually share the same edges between cells. Put another way, the boundaries
between each cell in a layer are always at an offset from the layer beneath it.
In one dimensional space, that looks like this:</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/scales.svg></p><p>This offset is what allows us to put an object into exactly one cell &ndash; if an
object overlaps an edge in one layer, we just need to bump up to the next layer.</p><p>Being in one cell allows queries and updates to be more efficient, as we don&rsquo;t
have to worry about deduplicating the results. We know that we can blindly emit
all the values within a cell without tracking what has already been returned.</p><p>Let&rsquo;s walk through the insertion process to see how this works.</p><h2 id=insert-operation>Insert operation<a hidden class=anchor aria-hidden=true href=#insert-operation>#</a></h2><p>To insert an object into the grid, we start by finding the smallest layer that
can fully contain that object:</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/insert-simple.svg></p><p>Above, the object is <code>3 units</code> wide at an offset of <code>3</code>. We can immediately choose an
initial <code>scale</code> by bumping the size up to the next power of 2, which puts us at a scale
of <code>4</code>. And because the object fits entirely within the cell from <code>2</code> to <code>5</code>, we&rsquo;re done.</p><p>However, if we do the above operation and the object overlaps the edge of its
destination cell, we need to keep working. To ensure it fits in exactly one
cell, we move up to the next layer until we find a cell where the object doesn&rsquo;t
overlap the boundaries.</p><p><img alt="ahgrid layers" loading=lazy src=/ahgrid/insert-bumped.svg></p><p>In the image above, you can see the same object as before, but this time it has
an offset of <code>4</code>. That puts the right edge over the right side boundary of the
cell. In this case, we can bump the scale up to <code>8</code> and the object now fits
entirely within a single cell.</p><h3 id=in-code>In code<a hidden class=anchor aria-hidden=true href=#in-code>#</a></h3><p>Lets look at the code for this. Imagine we want to insert a 2D object with <code>x</code>,
<code>y</code>, <code>width</code> and <code>height</code> parameters:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span>
</span></span><span style=display:flex><span>  SpatialObject<span style=color:#f92672>*</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>concept</span> obj
</span></span><span style=display:flex><span>    obj.x <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.y <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.width <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    obj.height <span style=color:#f92672>is</span> <span style=color:#66d9ef>int32</span>
</span></span></code></pre></div><p><strong>First</strong>, we choose the smallest layer that best fits this object. Because the cell size for
each layer is a power of 2, we just need to find the next power of two based on the maximum
width or height. That&rsquo;s the function we already showed above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> calculateScale(obj.width, obj.height)
</span></span></code></pre></div><p><strong>Second</strong>, we examine the <code>x</code> and <code>y</code> coordinates and independently choose a
cell index for each. This is basic bucketing &ndash; and it the same for both <code>x</code> and <code>y</code>, so we
can create a general function that works for both.</p><p>In a Hierarchical Spatial Hash Grid, this would just be <code>coord div scale</code>. But
because we need to offset the root coordinate for each layer by half the scale,
we need to get a bit fancier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>chooseBucket</span>(coord, scale: <span style=color:#66d9ef>int32</span>): <span style=color:#66d9ef>int32</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> half <span style=color:#f92672>=</span> scale <span style=color:#f92672>div</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># We need to specifically adjust the index to handle negative coordinates. This</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># looks funky because we also have to deal with the shifting root coordinates</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> adjust <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> coord <span style=color:#f92672>+</span> half <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>: <span style=color:#ae81ff>0</span><span style=color:#ae81ff>&#39;i32</span> <span style=color:#66d9ef>else</span>: <span style=color:#f92672>-</span>scale <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (coord <span style=color:#f92672>+</span> half <span style=color:#f92672>+</span> adjust) <span style=color:#f92672>div</span> scale <span style=color:#f92672>*</span> scale <span style=color:#f92672>-</span> half
</span></span></code></pre></div><p><strong>Third</strong>, we make sure the object we&rsquo;re processing fits entirely within the
cell we&rsquo;ve picked. If it doesn&rsquo;t, then we need to increase the <code>scale</code> of the
cell until the object can be fully contained by a single cell.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>pickCellIndex</span>(grid: AHGrid, x, y, width, height: <span style=color:#66d9ef>int32</span>): CellIndex <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> calculateScale(width, height)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>true</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> (xBucket: x.chooseBucket(scale), yBucket: y.chooseBucket(scale), scale: scale)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Ensure the object fits entirely within the cell</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>+</span> width <span style=color:#f92672>&lt;</span> output.xBucket <span style=color:#f92672>+</span> scale <span style=color:#f92672>and</span> y <span style=color:#f92672>+</span> height <span style=color:#f92672>&lt;</span> output.yBucket <span style=color:#f92672>+</span> scale:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If it doesn&#39;t, try fitting the object into the next layer up</span>
</span></span><span style=display:flex><span>    scale <span style=color:#f92672>=</span> scale <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Put that all together and we have now picked a single cell that we know will fit
the entire object.</p><h2 id=storage-and-inserting>Storage and Inserting<a hidden class=anchor aria-hidden=true href=#storage-and-inserting>#</a></h2><p>As already mentioned, the object being indexed are stored in a table of lists. All the
values with the same <code>CellIndex</code> are stored together, as they &ndash; by definition &ndash;
are near each other. It looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>type</span>
</span></span><span style=display:flex><span>  AHGrid<span style=color:#f92672>*[</span>T: SpatialObject<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>object</span>
</span></span><span style=display:flex><span>    maxScale: <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>    cells: Table<span style=color:#f92672>[</span>CellIndex, <span style=color:#66d9ef>seq</span><span style=color:#f92672>[</span>T<span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Notice that we also need to store the <code>maxScale</code>. That&rsquo;s in there so that queries know
how many layers they need to query before stopping. Any time we insert an object, we need
to update that <code>maxScale</code></p><p>With the type definition above, inserting an object can be done in linear time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>proc </span><span style=color:#a6e22e>insert</span><span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: <span style=color:#66d9ef>var</span> AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>, obj: T) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> obj.pickCellIndex(grid)
</span></span><span style=display:flex><span>  grid.maxScale <span style=color:#f92672>=</span> max(grid.maxScale, key.scale)
</span></span><span style=display:flex><span>  grid.cells.mgetOrPut(key, newSeq<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>()).add(obj)
</span></span></code></pre></div><h2 id=querying-at-a-point>Querying at a point<a hidden class=anchor aria-hidden=true href=#querying-at-a-point>#</a></h2><p>To find all the objects that are near a given point, we can implement a query by
calculating the <code>CellIndex</code> for each <code>scale</code> within the grid at the point of
interest. Visually, if you wanted to query for anything that exists at the 1d
coordinate <code>8</code>, it would look like this:</p><p><img alt="query at point" loading=lazy src=/ahgrid/query-point.svg></p><p>In the chart above, we would visit every cell at every layer that intersects with
the dashed line. In code, that looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>iterator</span> eachScale(grid: AHGrid): <span style=color:#66d9ef>int32</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> scale <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> scale <span style=color:#f92672>&lt;=</span> grid.maxScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> scale
</span></span><span style=display:flex><span>    scale <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>iterator</span> find<span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>; x, y: <span style=color:#66d9ef>int32</span>): T <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> scale <span style=color:#f92672>in</span> grid.eachScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> pickCellIndex(x, y, scale)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> obj <span style=color:#f92672>in</span> grid.cells.getOrDefault(keys):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span> obj
</span></span></code></pre></div><p>This dynamic scaling adapts smoothly to the size and spread of the data, minimizing unnecessary checks.</p><h2 id=querying-with-a-radius>Querying with a radius<a hidden class=anchor aria-hidden=true href=#querying-with-a-radius>#</a></h2><p>Within game development, it&rsquo;s common to need to know everything that is within
a specific radius of a given point. For example, finding all the enemies that might
be impacted by an explosion.</p><p>To handle this use case, we can add a radius to our query. This requires doing
a search for every <code>CellIndex</code> that is within the radius of the search point:</p><p><img alt="query at point" loading=lazy src=/ahgrid/query-range.svg></p><p>Again, we would need to visit every cell that intersects with or is between the
two dashed lines above. In code, that looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nim data-lang=nim><span style=display:flex><span><span style=color:#66d9ef>iterator</span> eachCellIndex(x, y, radius, scale: <span style=color:#66d9ef>int32</span>): CellIndex <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>## Yields each cell key within a given radius of a point at the given scale</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> (xLow, xHigh) <span style=color:#f92672>=</span> (chooseBucket(x <span style=color:#f92672>-</span> radius, scale), chooseBucket(x <span style=color:#f92672>+</span> radius, scale))
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> (yLow, yHigh)<span style=color:#f92672>=</span> (chooseBucket(y <span style=color:#f92672>-</span> radius, scale), chooseBucket(y <span style=color:#f92672>+</span> radius, scale))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> countup(xLow, xHigh, scale):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> countup(yLow, yHigh, scale):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span> (x, y, scale)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>iterator</span> find<span style=color:#f92672>*[</span>T<span style=color:#f92672>]</span>(grid: AHGrid<span style=color:#f92672>[</span>T<span style=color:#f92672>]</span>; x, y, radius: <span style=color:#66d9ef>int32</span>): T <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> scale <span style=color:#f92672>in</span> grid.eachScale:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> eachCellIndex(x, y, radius, scale):
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> obj <span style=color:#f92672>in</span> grid.cells.getOrDefault(key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> obj
</span></span></code></pre></div><h2 id=further-optimizations>Further Optimizations<a hidden class=anchor aria-hidden=true href=#further-optimizations>#</a></h2><p>Beyond what is described here, there are a few optimization strategies that need
further exploration:</p><ul><li><p>Initial Sizing for Hash Tables and Lists</p><p>When initializing your hash tables and nested lists, it‚Äôs helpful to estimate
the number of cells and objects you expect to store. By pre-allocating space
in the hash table and object lists, you can avoid costly reallocations as the
data grows.</p></li><li><p>Skip the hash table entirely</p><p>Technically, we don&rsquo;t even need a <code>Table</code>. We could use an array of arrays
and do the index management ourselves. This would let us guarantee that we never
have to deal with table resizing.</p></li><li><p>Adding a Minimum Scale (<code>minScale</code>)</p><p>Another critical parameter that can be added to this implementation is the
notion of a &ldquo;minimum scale&rdquo;, or <code>minScale</code>. This value sets the smallest cell
size used by the grid, acting as a lower bound for the <code>scale</code> factor. If the
<code>minScale</code> is too small, queries will need to search through many cells,
increasing the cost of each lookup. If it‚Äôs too large, you lose the
granularity and benefits of a spatial index.</p></li><li><p>Use a <code>HashSet</code> instead of a <code>seq</code></p><p>In the example code, I&rsquo;m using a <code>Table</code> that contains a <code>seq</code>. One possible
optimization would be using a <code>HashSet</code> instead. Though I didn&rsquo;t discuss the
<code>remove</code> or <code>update</code> operations in this article, using a set would potentially
make those operations faster.</p></li></ul><h2 id=strengths>Strengths<a hidden class=anchor aria-hidden=true href=#strengths>#</a></h2><ul><li><strong>Simplicity:</strong> Uses a flat hash table ‚Äî no deep tree traversals, no rebalancing. This
algorithm is <em>really</em> easy to implement</li><li><strong>Adaptability:</strong> Supports objects of any size at any position</li><li><strong>Efficient Queries:</strong> No deduplication needed due to unique cell assignments</li></ul><h2 id=weaknesses>Weaknesses<a hidden class=anchor aria-hidden=true href=#weaknesses>#</a></h2><ul><li><p><strong>Cache Locality:</strong> Because we&rsquo;re using a hash table, memory locality could
suffer. This is especially noticeable if the grid is large and queries need to
traverse multiple levels of scaling. Compared to a linear or tree-based
structure, the cache efficiency might be lower.</p></li><li><p><strong>Large Query Radii:</strong> A large query radius is going to cause a lot of cells
to be visited, reducing efficiency. This could be a bigger issue if large
queries are frequent</p></li><li><p><strong>Integer only:</strong> This implementation relies on a lot of integer based math and
doesn&rsquo;t really work for floats. Any usage would first need to convert a float to
an int. This is trivial with a fixed point system, though.</p></li><li><p><strong>Scaling Factor Sensitivity:</strong> Choosing the right <code>minScale</code> is crucial. If the scaling
is off, it can lead to either too many grid levels (increasing overhead) or too few (leading
to dense cells that degrade query performance).</p></li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>There are certainly some improvements and extensions that can be made to this implementation.
For example, being able to remove objects or update them in place. Supporting 3D objects, too.
Those should be fairly straight forward.</p><p>I&rsquo;ve been using this for Game development, where I need to quickly and dynamically
index a large number of game entities &ndash; it has worked well so far!</p><p>If you&rsquo;re interested in seeing all this code together, I&rsquo;ve got a working implementation
over on Github: <a href=https://github.com/Nycto/AHGrid>https://github.com/Nycto/AHGrid</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://elephantstarballoon.com/>üêò‚≠êüéà</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>